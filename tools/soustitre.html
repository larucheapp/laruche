<!DOCTYPE html>
<html lang="fr" data-app="laruche">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CaptionFlow</title>
  <meta name="description" content="Générateur de sous-titres dynamiques style 'Submagic' pour vidéos verticales via Google Gemini.">
  <style>
    :root{
      --color-bg:#FFFFFF;
      --color-bg-alt:#F7F8FA;
      --color-border:#E9EAF0;
      --color-text-primary:#141417;
      --color-text-secondary:#6B7280;
      --color-violet:#7C3AED;
      --color-violet-dark:#6D28D9;
      --radius-md:12px;
      --radius-lg:14px;
      --tool-max-w:480px;
    }

    *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
    html{height:100%;background-color:var(--color-bg)}
    body{
      height:100vh; overflow:hidden; display:flex; flex-direction:column;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Inter",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
      color:var(--color-text-primary); line-height:1.5; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    body[data-size="default"]{--tool-max-w:480px}
    body[data-size="wide"]{--tool-max-w:960px}
    body[data-size="xl"]{--tool-max-w:1200px}

    #bg-canvas{position:fixed;inset:0;width:100%;height:100%;z-index:-1}

    .app-header{
      flex-shrink:0; background:var(--color-bg-alt); border-bottom:1px solid var(--color-border);
      padding:0 24px; display:flex; align-items:center; height:70px;
    }
    .app-header a{display:inline-flex; align-items:center}
    .logo-img{height:70px; width:auto; vertical-align:middle}

    .main-content{
      flex-grow:1; display:flex; flex-direction: column; align-items:center; justify-content:flex-start;
      padding:48px 24px; overflow-y:auto;
    }
    .tool-wrapper{display:flex; flex-direction:column; align-items:center; position:relative; width: 100%; margin: 0 auto;}
    .tool-title{
      font-size:1.75rem; font-weight:600; padding:12px 28px;
      background:linear-gradient(45deg,var(--color-violet),var(--color-violet-dark));
      color:#fff; border-radius:var(--radius-md); margin-bottom:-20px; position:relative; z-index:5;
      box-shadow:0 4px 14px -4px rgba(124,58,237,.4);
    }
    .generator-card{
      background:var(--color-bg); border:1px solid var(--color-border); border-radius:var(--radius-lg);
      padding:28px; padding-top:40px; width:100%; max-width:var(--tool-max-w);
      box-shadow:0 4px 6px -1px rgb(0 0 0 / 5%), 0 2px 4px -2px rgb(0 0 0 / 5%);
      display:flex; flex-direction:column; gap:24px;
    }
    .form-group{display:flex; flex-direction:column; gap:8px}
    .form-label{font-weight:500; color:var(--color-text-primary)}
    .form-input{
      width:100%; padding:10px 14px; border:1px solid var(--color-border); border-radius:var(--radius-md);
      font-size:1rem; color:var(--color-text-primary); background:var(--color-bg);
      transition:border-color .2s, box-shadow .2s;
    }
    .form-input:focus{outline:none; border-color:var(--color-violet); box-shadow:0 0 0 3px rgba(124,58,237,.2)}
    .actions{display:flex; justify-content:flex-end; gap:12px}
    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      font-weight:500; padding:10px 16px; border-radius:var(--radius-md); border:none; cursor:pointer;
      transition:background-color .2s, box-shadow .2s; font-size:14px;
    }
    .btn:focus-visible{outline:2px solid transparent; outline-offset:2px; box-shadow:0 0 0 3px rgba(124,58,237,.4)}
    .btn-primary{background:var(--color-violet); color:#fff}
    .btn-primary:hover:not(:disabled){background:var(--color-violet-dark)}
    .btn-primary:disabled{background:#A78BFA; cursor:not-allowed}
    .status-text{font-size:14px; color:var(--color-text-secondary); text-align:center; min-height:21px}

    /* STYLES SPECIFIQUES CAPTIONFLOW */
    .layout-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 32px;
    }
    @media (max-width: 800px) {
        .layout-grid { grid-template-columns: 1fr; }
    }

    .video-preview-container {
        position: relative;
        width: 100%;
        aspect-ratio: 9/16;
        background: #000;
        border-radius: var(--radius-md);
        overflow: hidden;
        box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
        margin: 0 auto;
        max-width: 320px; 
    }
    
    video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
    }

    /* Overlay pour le preview HTML simple (fallback) */
    .subtitle-overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
        text-align: center;
        /* On place le texte aux 3/4 bas par défaut pour simuler la position réelle */
        align-items: flex-end; 
        padding-bottom: 30%;
    }

    .subtitle-text {
        /* Style de base reset */
        max-width: 90%;
        margin: 0 auto;
        line-height: 1.2;
    }

    .step-hidden { display: none; }
    .style-selector {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
    }
    .style-btn {
        padding: 12px 8px;
        border: 1px solid var(--color-border);
        border-radius: var(--radius-md);
        background: var(--color-bg);
        cursor: pointer;
        font-size: 0.9rem;
        text-align: center;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .style-btn:hover { border-color: var(--color-violet); }
    .style-btn.active {
        border-color: var(--color-violet);
        background-color: rgba(124,58,237,0.05);
        color: var(--color-violet);
        font-weight: 600;
        box-shadow: 0 0 0 2px rgba(124,58,237,0.1);
    }

    .drop-zone {
        border: 2px dashed var(--color-border);
        border-radius: var(--radius-md);
        padding: 32px;
        text-align: center;
        cursor: pointer;
        transition: border-color 0.2s;
        background: var(--color-bg-alt);
    }
    .drop-zone:hover { border-color: var(--color-violet); }
    .drop-zone p { margin-top: 8px; color: var(--color-text-secondary); font-size: 0.9rem; }

    .loader {
        width: 20px; height: 20px;
        border: 2px solid #fff;
        border-bottom-color: transparent;
        border-radius: 50%;
        display: inline-block;
        animation: rotation 1s linear infinite;
    }
    @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    .progress-container {
        width: 100%; background: var(--color-border); height: 6px; border-radius: 3px; overflow: hidden; margin-top:8px;
    }
    .progress-bar {
        height: 100%; background: var(--color-violet); width: 0%; transition: width 0.1s linear;
    }
  </style>
<link rel="stylesheet" href="/index.css">
</head>
<body data-size="wide">
  <canvas id="bg-canvas"></canvas>

  <header class="app-header">
    <a href="/" aria-label="Accueil">
      <img src="logo-2.png" alt="Logo La Ruche" class="logo-img">
    </a>
  </header>

  <main class="main-content">
    <div class="tool-wrapper">
      <h1 class="tool-title">CaptionFlow</h1>

      <div class="generator-card" role="region" aria-label="CaptionFlow">
        
        <div class="layout-grid">
            <!-- LEFT COLUMN: CONTROLS -->
            <div style="display: flex; flex-direction: column; gap: 24px;">
                
                <!-- API KEY -->
                <div class="form-group">
                    <label class="form-label" for="api-key">Clé API Google AI Studio</label>
                    <input type="password" id="api-key" class="form-input" placeholder="Collez votre clé ici (commence par AIza...)" autocomplete="off">
                    <p style="font-size: 0.8rem; color: var(--color-text-secondary);">
                        Votre clé est utilisée localement. <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color:var(--color-violet)">Obtenir une clé</a>
                    </p>
                </div>

                <!-- UPLOAD -->
                <div class="form-group">
                    <label class="form-label">Vidéo (Verticale, Max 60s)</label>
                    <div class="drop-zone" id="drop-zone">
                        <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" style="color:var(--color-text-secondary)"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>
                        <p>Cliquez ou déposez une vidéo (MP4)</p>
                        <input type="file" id="file-input" accept="video/mp4,video/quicktime,video/webm" style="display:none">
                    </div>
                </div>

                <!-- SETTINGS -->
                <div id="settings-panel" class="step-hidden form-group">
                    <label class="form-label">Style des sous-titres</label>
                    <div class="style-selector">
                        <button class="style-btn active" data-style="hormozi">Hormozi</button>
                        <button class="style-btn" data-style="neon">Néon</button>
                        <button class="style-btn" data-style="clean">Clean</button>
                        <button class="style-btn" data-style="comic">Comic</button>
                        <button class="style-btn" data-style="boxy">Boxy</button>
                        <button class="style-btn" data-style="fire">Fire</button>
                    </div>
                    
                    <div style="margin-top: 24px;">
                        <button id="btn-generate" class="btn btn-primary" style="width: 100%;">
                            <span id="btn-text">Générer les sous-titres</span>
                        </button>
                    </div>
                </div>

                <div id="export-panel" class="step-hidden form-group">
                     <p class="status-text" id="export-status">Prêt à exporter</p>
                     <div class="progress-container" id="progress-container" style="display:none">
                        <div class="progress-bar" id="progress-bar"></div>
                     </div>
                     <button id="btn-download" class="btn btn-primary" style="width: 100%; margin-top:12px;">
                        Télécharger la vidéo (1 min max)
                     </button>
                </div>
                
                <div id="error-msg" style="color: #ef4444; font-size: 0.9rem; display: none;"></div>
            </div>

            <!-- RIGHT COLUMN: PREVIEW -->
            <div style="display: flex; flex-direction: column; gap: 12px; align-items: center; justify-content: center;">
                <div class="video-preview-container" id="preview-container">
                    <video id="main-video" playsinline muted></video>
                    <!-- Overlay HTML pour le feedback immédiat (moins précis que le canvas final) -->
                    <div class="subtitle-overlay">
                        <div id="subtitle-display" class="subtitle-text"></div>
                    </div>
                </div>
                <p class="status-text">Aperçu Rapide (Le rendu final sera de meilleure qualité)</p>
            </div>
        </div>

      </div>
    </div>
  </main>

  <script>
    // --- Background Hex Grid (MANDATORY LA RUCHE) ---
    (function(){
      const c = document.getElementById('bg-canvas');
      const ctx = c.getContext('2d');
      function draw(){
        const dpr = window.devicePixelRatio || 1;
        const rect = c.getBoundingClientRect();
        c.width = rect.width * dpr; c.height = rect.height * dpr;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        ctx.clearRect(0,0,rect.width,rect.height);

        const size = 24;
        const hexW = 2 * size;
        const hexH = Math.sqrt(3) * size;
        const stepX = hexW * 3/4;
        ctx.strokeStyle = 'rgba(124,58,237,0.10)';
        ctx.lineWidth = 1;

        for(let row=0; row*hexH < rect.height + hexH; row++){
          for(let col=0; col*stepX < rect.width + hexW; col++){
            const x = col * stepX;
            const y = row * hexH + (col % 2 ? hexH/2 : 0);
            ctx.beginPath();
            for(let i=0;i<6;i++){
              const a = 2 * Math.PI / 6 * i;
              const px = x + size * Math.cos(a);
              const py = y + size * Math.sin(a);
              if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
            }
            ctx.closePath(); ctx.stroke();
          }
        }
      }
      window.addEventListener('resize', draw, {passive:true});
      draw();
    })();

    // --- CAPTIONFLOW APP LOGIC ---

    const MAX_DURATION = 60; 

    // State
    let state = {
        apiKey: '',
        videoFile: null,
        videoBase64: null, 
        subtitles: [], 
        currentStyle: 'hormozi',
        isGenerating: false
    };

    // DOM Elements
    const apiKeyInput = document.getElementById('api-key');
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const videoEl = document.getElementById('main-video');
    const subtitleDisplay = document.getElementById('subtitle-display');
    const btnGenerate = document.getElementById('btn-generate');
    const btnDownload = document.getElementById('btn-download');
    const btnText = document.getElementById('btn-text');
    const errorMsg = document.getElementById('error-msg');
    const settingsPanel = document.getElementById('settings-panel');
    const exportPanel = document.getElementById('export-panel');
    const styleBtns = document.querySelectorAll('.style-btn');
    const progressBar = document.getElementById('progress-bar');
    const progressContainer = document.getElementById('progress-container');
    const exportStatus = document.getElementById('export-status');

    // Event Listeners
    apiKeyInput.addEventListener('input', (e) => state.apiKey = e.target.value.trim());
    
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.borderColor = 'var(--color-violet)'; });
    dropZone.addEventListener('dragleave', () => dropZone.style.borderColor = 'var(--color-border)');
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.style.borderColor = 'var(--color-border)';
        if(e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', (e) => {
        if(e.target.files.length) handleFile(e.target.files[0]);
    });

    styleBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            styleBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            state.currentStyle = btn.dataset.style;
            updateHtmlPreview(state.currentStyle);
        });
    });

    btnGenerate.addEventListener('click', generateSubtitles);
    btnDownload.addEventListener('click', burnAndDownload);

    videoEl.addEventListener('timeupdate', () => {
        if (!state.subtitles.length) return;
        const t = videoEl.currentTime;
        // Loop preview at 60s
        if (t >= MAX_DURATION && !videoEl.paused) {
             videoEl.pause();
             videoEl.currentTime = 0;
        }
        
        const sub = state.subtitles.find(s => t >= s.start && t < s.end);
        if (sub) {
            subtitleDisplay.textContent = sub.text;
            subtitleDisplay.style.opacity = 1;
            // Simple scale animation for HTML preview
            subtitleDisplay.style.transform = getHtmlPreviewTransform(state.currentStyle, true);
            setTimeout(() => {
                subtitleDisplay.style.transform = getHtmlPreviewTransform(state.currentStyle, false);
            }, 100);
        } else {
            subtitleDisplay.style.opacity = 0;
        }
    });

    // Helper for transform
    function getHtmlPreviewTransform(style, isPop) {
        let base = 'scale(1)';
        if(style === 'comic') base = 'rotate(-2deg)';
        if(style === 'boxy') base = 'skewX(-10deg)';
        
        if(isPop) return `${base} scale(1.1)`;
        return base;
    }

    // Functions

    function showError(msg) {
        errorMsg.textContent = msg;
        errorMsg.style.display = 'block';
        setTimeout(() => errorMsg.style.display = 'none', 8000);
    }

    function handleFile(file) {
        if (!file.type.startsWith('video/')) {
            showError("Le fichier doit être une vidéo.");
            return;
        }
        if (file.size > 30 * 1024 * 1024) {
             showError("Attention: Vidéo volumineuse (>30Mo). Le traitement peut être lent.");
        }

        state.videoFile = file;
        const url = URL.createObjectURL(file);
        videoEl.src = url;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const base64 = e.target.result.split(',')[1];
            state.videoBase64 = base64;
            settingsPanel.classList.remove('step-hidden');
            dropZone.querySelector('p').textContent = file.name;
            updateHtmlPreview('hormozi');
        };
        reader.readAsDataURL(file);
    }

    function updateHtmlPreview(style) {
        // Reset base styles
        subtitleDisplay.style.cssText = '';
        subtitleDisplay.className = 'subtitle-text';
        subtitleDisplay.style.opacity = 1;
        
        // Base common styles
        subtitleDisplay.style.textAlign = 'center';
        subtitleDisplay.style.transition = 'transform 0.1s';
        
        // Show text if empty for preview
        if(!state.subtitles.length && !videoEl.src) {
             subtitleDisplay.textContent = "STYLE PREVIEW";
        }

        switch(style) {
            case 'hormozi':
                subtitleDisplay.style.color = '#FFE600';
                subtitleDisplay.style.textShadow = '2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 3px 3px 0 #000'; 
                subtitleDisplay.style.fontFamily = '"Inter", "Roboto", sans-serif';
                subtitleDisplay.style.fontWeight = '900';
                subtitleDisplay.style.textTransform = 'uppercase';
                subtitleDisplay.style.fontSize = '1.8rem';
                break;
                
            case 'neon':
                subtitleDisplay.style.color = '#fff';
                subtitleDisplay.style.textShadow = '0 0 10px #ff00de, 0 0 20px #ff00de';
                subtitleDisplay.style.fontFamily = '"Courier New", monospace';
                subtitleDisplay.style.fontWeight = '700';
                subtitleDisplay.style.fontSize = '1.5rem';
                break;
                
            case 'clean':
                subtitleDisplay.style.color = '#fff';
                subtitleDisplay.style.fontFamily = 'sans-serif';
                subtitleDisplay.style.fontWeight = '600';
                subtitleDisplay.style.backgroundColor = 'rgba(0,0,0,0.7)';
                subtitleDisplay.style.padding = '4px 12px';
                subtitleDisplay.style.borderRadius = '12px';
                subtitleDisplay.style.fontSize = '1.4rem';
                subtitleDisplay.style.display = 'inline-block'; 
                break;
                
            case 'comic':
                subtitleDisplay.style.color = '#fff';
                subtitleDisplay.style.fontFamily = '"Comic Sans MS", "Chalkboard SE", sans-serif';
                subtitleDisplay.style.fontWeight = '900';
                subtitleDisplay.style.textShadow = '2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000';
                subtitleDisplay.style.transform = 'rotate(-2deg)';
                subtitleDisplay.style.fontSize = '1.8rem';
                break;
                
            case 'boxy':
                subtitleDisplay.style.fontFamily = '"Anton", "Impact", "Arial Black", sans-serif';
                subtitleDisplay.style.fontWeight = '900';
                subtitleDisplay.style.color = '#000';
                subtitleDisplay.style.backgroundColor = '#fff';
                subtitleDisplay.style.padding = '4px 8px';
                subtitleDisplay.style.transform = 'skewX(-10deg)';
                subtitleDisplay.style.boxShadow = '5px 5px 0 #000';
                subtitleDisplay.style.fontSize = '1.8rem';
                subtitleDisplay.style.textTransform = 'uppercase';
                subtitleDisplay.style.display = 'inline-block';
                break;
                
            case 'fire':
                subtitleDisplay.style.fontFamily = '"Verdana", sans-serif';
                subtitleDisplay.style.fontWeight = '900';
                subtitleDisplay.style.fontStyle = 'italic';
                subtitleDisplay.style.fontSize = '1.8rem';
                subtitleDisplay.style.background = 'linear-gradient(to bottom, #FFFF00 0%, #FF4500 100%)';
                subtitleDisplay.style.webkitBackgroundClip = 'text';
                subtitleDisplay.style.webkitTextFillColor = 'transparent';
                subtitleDisplay.style.color = '#FF4500'; // Fallback
                subtitleDisplay.style.filter = 'drop-shadow(0px 0px 2px rgba(139,0,0,1)) drop-shadow(0px 0px 5px orange)';
                break;
        }
    }

    async function generateSubtitles() {
        if (!state.apiKey) return showError("Veuillez entrer votre clé API.");
        if (!state.videoBase64) return showError("Aucune vidéo chargée.");

        state.isGenerating = true;
        btnGenerate.disabled = true;
        btnText.innerHTML = '<span class="loader"></span> Analyse IA (Haute Précision)...';
        errorMsg.style.display = 'none';
        
        try {
            const prompt = `
                You are a professional video editor creating subtitles for a viral TikTok video.
                Task: Listen to the audio and transcribe it into precise subtitles.
                CRITICAL RULES FOR PACING:
                1. Break text into VERY SHORT segments (1 to 3 words MAX). 
                2. Timestamps must be extremely accurate.
                3. Return ONLY a JSON array: [{"start": 0.0, "end": 0.5, "text": "Hello"}, ...].
                4. Process only the first 60 seconds.
            `;

            const payload = {
                contents: [{
                    parts: [
                        { text: prompt },
                        { inline_data: { mime_type: state.videoFile.type, data: state.videoBase64 } }
                    ]
                }],
                generationConfig: {
                    response_mime_type: "application/json",
                    temperature: 0.3
                }
            };

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${state.apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error?.message || "Erreur API inconnue");
            }

            const data = await response.json();
            if (!data.candidates || !data.candidates[0].content) {
                 throw new Error("Aucune réponse de l'IA. Réessayez.");
            }
            
            const rawText = data.candidates[0].content.parts[0].text;
            let jsonStr = rawText.trim();
            if (jsonStr.startsWith('```json')) jsonStr = jsonStr.replace(/^```json/, '').replace(/```$/, '');
            if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/^```/, '').replace(/```$/, '');

            const parsed = JSON.parse(jsonStr);
            
            state.subtitles = parsed.map((sub, i) => {
                if(i < parsed.length - 1 && parsed[i+1].start < sub.end) {
                    sub.end = parsed[i+1].start;
                }
                return sub;
            });
            
            btnText.textContent = "Sous-titres générés !";
            exportPanel.classList.remove('step-hidden');
            videoEl.play(); 
            
        } catch (e) {
            console.error(e);
            showError("Erreur : " + e.message);
            btnText.textContent = "Réessayer";
        } finally {
            state.isGenerating = false;
            btnGenerate.disabled = false;
        }
    }

    async function burnAndDownload() {
        if(!state.subtitles.length) return;

        btnDownload.disabled = true;
        progressContainer.style.display = 'block';
        exportStatus.textContent = "Préparation du rendu haute fidélité...";

        // 1. Isolation: Création d'un élément vidéo dédié pour l'export (Offscreen)
        // Cela évite les conflits avec le lecteur principal et assure un rendu propre
        const offVideo = document.createElement('video');
        offVideo.src = videoEl.src;
        offVideo.crossOrigin = "anonymous";
        offVideo.muted = false; 
        
        await new Promise(resolve => {
            offVideo.onloadedmetadata = resolve;
            offVideo.load();
        });

        // 2. Configuration Canvas avec limite de résolution (1080p Max)
        // Empêche le crash sur les vidéos 4K en redimensionnant intelligemment
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const MAX_DIM = 1920; 
        let vWidth = offVideo.videoWidth;
        let vHeight = offVideo.videoHeight;
        
        // Downscale si trop grand
        if (vWidth > MAX_DIM || vHeight > MAX_DIM) {
            const ratio = vWidth / vHeight;
            if (vWidth > vHeight) {
                vWidth = MAX_DIM;
                vHeight = Math.round(MAX_DIM / ratio);
            } else {
                vHeight = MAX_DIM;
                vWidth = Math.round(MAX_DIM * ratio);
            }
        }
        
        canvas.width = vWidth;
        canvas.height = vHeight;

        // 3. Audio Pipeline
        // Création d'un contexte unique pour cet export
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaElementSource(offVideo);
        const dest = audioCtx.createMediaStreamDestination();
        source.connect(dest);
        // On ne connecte pas à la destination finale pour éviter l'écho pendant l'export

        const stream = canvas.captureStream(30);
        const combinedStream = new MediaStream([
            ...stream.getVideoTracks(),
            ...dest.stream.getAudioTracks()
        ]);

        // 4. MediaRecorder avec Bitrate optimisé
        // 4Mbps est un excellent compromis Qualité/Stabilité pour le web
        let options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 4000000 };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            options = { mimeType: 'video/webm' }; // Fallback compatibilité
        }
        
        const mediaRecorder = new MediaRecorder(combinedStream, options);
        const chunks = [];
        mediaRecorder.ondataavailable = (e) => {
            if(e.data.size > 0) chunks.push(e.data);
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `captionflow_${Date.now()}.webm`;
            a.click();
            
            exportStatus.textContent = "Export terminé !";
            btnDownload.disabled = false;
            progressBar.style.width = '0%';
            progressContainer.style.display = 'none';
            
            // Nettoyage complet
            source.disconnect();
            audioCtx.close();
            offVideo.remove();
        };

        // 5. Boucle de rendu synchronisée (requestVideoFrameCallback)
        // C'est la CLÉ pour éviter le freeze : on dessine seulement quand la frame est prête
        const drawFrame = (now, metadata) => {
            if (offVideo.paused || offVideo.ended || offVideo.currentTime >= MAX_DURATION) {
                mediaRecorder.stop();
                offVideo.pause();
                return;
            }

            // Mise à jour barre de progression
            const pct = (offVideo.currentTime / Math.min(offVideo.duration, MAX_DURATION)) * 100;
            progressBar.style.width = `${pct}%`;

            // Dessin Vidéo
            ctx.drawImage(offVideo, 0, 0, vWidth, vHeight);

            // Dessin Sous-titres (Logique identique à la preview mais sur le canvas offscreen)
            const t = offVideo.currentTime;
            const sub = state.subtitles.find(s => t >= s.start && t < s.end);
            
            if (sub) {
                ctx.save();
                
                const centerX = vWidth / 2;
                const centerY = vHeight * 0.75; 
                const txt = sub.text.toUpperCase();
                
                // Animation Pop
                const timeSinceStart = t - sub.start;
                let scale = 1;
                if (timeSinceStart < 0.15) {
                    const x = timeSinceStart / 0.15;
                    scale = 0.8 + (1.2 * x * (1 - x)) + (1 * x*x); 
                    if(scale > 1.1) scale = 1.1; 
                }

                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // --- Rendu des Styles (Copie de la logique de style) ---
                if (state.currentStyle === 'hormozi') {
                    const fontSize = vWidth * 0.09;
                    ctx.font = `900 ${fontSize}px "Inter", sans-serif`;
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = fontSize * 0.2;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(txt, 0, 0);
                    ctx.fillStyle = '#000000';
                    ctx.fillText(txt, fontSize * 0.08, fontSize * 0.08);
                    ctx.fillStyle = '#FFE600'; 
                    ctx.fillText(txt, 0, 0);

                } else if (state.currentStyle === 'neon') {
                    const fontSize = vWidth * 0.08;
                    ctx.font = `700 ${fontSize}px "Courier New", monospace`;
                    ctx.shadowColor = '#ff00de';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(txt, 0, 0);
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(txt, 0, 0);

                } else if (state.currentStyle === 'comic') {
                    const fontSize = vWidth * 0.1;
                    ctx.font = `900 ${fontSize}px "Comic Sans MS", "Chalkboard SE", sans-serif`;
                    ctx.rotate(-2 * Math.PI / 180);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = fontSize * 0.2;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(txt, 0, 0);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(txt, 0, 0);

                } else if (state.currentStyle === 'boxy') {
                    const fontSize = vWidth * 0.09;
                    ctx.font = `900 ${fontSize}px "Anton", "Impact", "Arial Black", sans-serif`;
                    const metrics = ctx.measureText(txt);
                    const w = metrics.width + 40;
                    const h = fontSize * 1.3;
                    ctx.transform(1, 0, -0.2, 1, 0, 0); 
                    ctx.fillStyle = '#000000';
                    ctx.fillRect((-w/2) + 8, (-h/2) + 8, w, h);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(-w/2, -h/2, w, h);
                    ctx.fillStyle = '#000000';
                    ctx.fillText(txt, 0, 0);

                } else if (state.currentStyle === 'fire') {
                    const fontSize = vWidth * 0.1;
                    ctx.font = `900 italic ${fontSize}px "Verdana", sans-serif`;
                    ctx.strokeStyle = '#8B0000';
                    ctx.lineWidth = fontSize * 0.1;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(txt, 0, 0);
                    const grad = ctx.createLinearGradient(0, -fontSize/2, 0, fontSize/2);
                    grad.addColorStop(0, "#FFFF00");
                    grad.addColorStop(0.5, "#FFA500");
                    grad.addColorStop(1, "#FF4500");
                    ctx.fillStyle = grad;
                    ctx.shadowColor = 'orange';
                    ctx.shadowBlur = 30;
                    ctx.fillText(txt, 0, 0);
                    ctx.shadowBlur = 0; 

                } else { // Clean
                    const fontSize = vWidth * 0.07;
                    ctx.font = `600 ${fontSize}px sans-serif`;
                    const metrics = ctx.measureText(txt);
                    const w = metrics.width + 40;
                    const h = fontSize * 1.4;
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.roundRect(-w/2, -h/2, w, h, 16);
                    ctx.fill();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(sub.text, 0, 0);
                }

                ctx.restore();
            }

            // Boucle via rVFC si dispo, sinon rAF
            if ('requestVideoFrameCallback' in offVideo) {
                offVideo.requestVideoFrameCallback(drawFrame);
            } else {
                requestAnimationFrame(drawFrame);
            }
        };

        // Lancement
        exportStatus.textContent = "Rendu en cours...";
        await offVideo.play();
        mediaRecorder.start();
        
        if ('requestVideoFrameCallback' in offVideo) {
            offVideo.requestVideoFrameCallback(drawFrame);
        } else {
            requestAnimationFrame(drawFrame);
        }
    }

    if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.beginPath();
            this.moveTo(x + r, y);
            this.arcTo(x + w, y, x + w, y + h, r);
            this.arcTo(x + w, y + h, x, y + h, r);
            this.arcTo(x, y + h, x, y, r);
            this.arcTo(x, y, x + w, y, r);
            this.closePath();
            return this;
        };
    }
  </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
